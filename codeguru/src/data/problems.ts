import { CodingProblem } from "./types";

export const CODING_PROBLEMS: CodingProblem[] = [
    {
      id: 'graph-connectivity',
      title: 'Graph Connectivity Check',
      description: 'Complete the code to determine if an undirected graph is connected using BFS.',
      codeLines: [
        'def is_connected(graph):',
        '    if not graph:',
        '        return False',
        '',
        '    first = list(graph.keys())[0]',
        '    to_visit = [first]',
        '    seen = {first}',
        '',
        '    while _____1_____:',
        '        curr = _____2_____',
        '        for neighbor in graph[curr]:',
        '            if _____3_____:',
        '                seen.add(neighbor)',
        '                _____4_____',
        '',
        '    return len(seen) == _____5_____'
      ],
      tokens: [
        'to_visit.pop()',
        'seen.remove',
        'to_visit',
        'len(seen)',
        'to_visit.append(neighbor)',
        'neighbor in seen',
        'neighbor not in seen',
        'len(graph)'
      ],
      solutions: {
        '1': 'to_visit',
        '2': 'to_visit.pop()',
        '3': 'neighbor not in seen',
        '4': 'to_visit.append(neighbor)',
        '5': 'len(graph)'
      },
      hints: {
        '1': 'We need to continue while there are nodes to visit',
        '2': 'We should remove and return the next node to process',
        '3': 'We only want to process nodes we haven\'t seen before',
        '4': 'Add the new neighbor to our queue of nodes to visit',
        '5': 'The graph is connected if we\'ve seen all nodes'
      },
      tags: ['graph', 'bfs']
    },
    {
      id: 'binary-search',
      title: 'Binary Search Implementation',
      description: 'Complete the code for a binary search algorithm.',
      codeLines: [
        'def binarySearch(arr, target):',
        '  left = 0',
        '  right = _____1_____',
        '',
        '  while (_____2_____):',
        '    mid = _____3_____',
        '    if (arr[mid] === target):',
        '      return mid',
        '    elif (_____4_____):',
        '      left = mid + 1',
        '    else:',
        '      right = _____5_____',
        '  return -1',
      ],
      tokens: [
        'len(arr) - 1',
        'left <= right',
        'left >= right',
        '(left + right) / 2',
        '(left + right) // 2',
        'arr[mid] < target',
        'mid - 1',
        'mid + 1'
      ],
      solutions: {
        '1': 'len(arr) - 1',
        '2': 'left <= right',
        '3': '(left + right) // 2',
        '4': 'arr[mid] < target',
        '5': 'mid - 1'
      },
      hints: {
        "1": "Initialize the right boundary of the search to the last index of the array.",
        "2": "Continue searching while the left index does not surpass the right index.",
        "3": "Find the middle index of the current search range.",
        "4": "If the middle element is smaller than the target, narrow the search to the right half.",
        "5": "If the middle element is greater than the target, narrow the search to the left half."
  },
  tags: ['binary-search', 'fundamentals', 'lc-easy']
    },
    {
      id: 'sliding-window-min-sum',
      title: 'Smallest array for a given sum ',
      description: 'Given an array of positive integers and a number S, find the length of the smallest contiguous subarray whose sum is greater than or equal to S. Return 0 if no such subarray exists.',
      codeLines: [
        'def findMinSubArray(self, s, arr):',
        ' window_sum = 0',
        ' min_length = math.inf',
        ' window_start = 0',
        '',
        'for window_end in range(0, len(arr)):',
        '    window_sum += _____1_____',
        '    while _____2_____:',
        '        min_length = min(min_length, _____3_____)',
        '        window_sum -= _____4_____',
        '        _____5_____',
        '',
        'if min_length == math.inf:',
        '    return 0',
        'return min_length'
      ],
      tokens: [
        'window_sum >= s',
        'arr[window_end]',
        'window_sum <= s',
        'window_end - window_start + 1',
        'window_end - window_start',
        'arr[window_start]',
        'window_start += 1',
        'window_end -= 1'
      ],
      solutions: {
        '1': 'arr[window_end]',
        '2': 'window_sum >= s',
        '3': 'window_end - window_start + 1',
        '4': 'arr[window_start]',
        '5': 'window_start += 1'
      },
      hints: {
        "1": "Expand the window by adding the current element to the running sum.",
        "2": "Shrink the window when the sum meets or exceeds the target value.",
        "3": "Update the minimum length by considering the current window size.",
        "4": "Since we're shrinking the window, subtract the element at the start of the window.",
        "5": "Move the window forward by incrementing the start index."
      },
  tags: ['sliding-window', 'array']

    },
    {
      "id": "longest-substring-k-distinct",
      "title": "Longest Substring with K Distinct Characters",
      "description": "Complete the code to find the length of the longest substring with no more than K distinct characters.",
      "codeLines": [
          "def findLength(self, str1, k):",
          "    window_start = 0",
          "    max_length = 0",
          "    char_frequency = {}",
          "",
          "    for window_end in range(len(str1)):",
          "        right_char = str1[window_end]",
          "        if right_char not in char_frequency:",
          "            _____1_____",
          "        _____2_____",
          "",
          "        while len(char_frequency) > k:",
          "            left_char = str1[window_start]",
          "            _____3_____",
          "            if char_frequency[left_char] == 0:",
          "                _____4_____",
          "            window_start += 1",
          "",
          "        max_length = max(max_length, _____5_____)",
          "    return max_length"
      ],
      "tokens": [
          "char_frequency[right_char] = 0",
          "char_frequency[right_char] += 1",
          "char_frequency[left_char] -= 1",
          "del char_frequency[left_char]",
          "window_end - window_start + 1",
          "char_frequency.clear()",
          "window_start - window_end",
          "len(char_frequency)"
      ],
      "solutions": {
          "1": "char_frequency[right_char] = 0",
          "2": "char_frequency[right_char] += 1",
          "3": "char_frequency[left_char] -= 1",
          "4": "del char_frequency[left_char]",
          "5": "window_end - window_start + 1"
      },
      "hints": {
          "1": "Initialize the frequency count for a new character in the window.",
          "2": "Increase the frequency count for the current character.",
          "3": "Decrease the frequency count when shrinking the window.",
          "4": "Remove a character from the frequency dictionary when its count reaches zero.",
          "5": "Track the longest valid substring length."
      },
  tags: ['sliding-window', 'string']
      
    },
    {
      "id": "longest-substring-same-letters-replacement",
      "title": "Longest Substring with Same Letters after Replacement",
      "description": "Complete the code to find the length of the longest substring where you can replace up to K letters to make all characters the same.",
      "codeLines": [
          "def findLength(self, str1, k):",
          "    window_start, max_length, max_repeat_letter_count = 0, 0, 0",
          "    frequency_map = {}",
          "",
          "    for window_end in range(len(str1)):",
          "        right_char = str1[window_end]",
          "        if right_char not in frequency_map:",
          "            _____1_____",
          "        _____2_____",
          "",
          "        max_repeat_letter_count = max(max_repeat_letter_count, _____3_____)",
          "",
          "        if (window_end - window_start + 1 - max_repeat_letter_count) > k:",
          "            left_char = str1[window_start]",
          "            _____4_____",
          "            window_start += 1",
          "",
          "        max_length = max(max_length, _____5_____)",
          "    return max_length"
      ],
      "tokens": [
          "frequency_map[right_char] = 0",
          "frequency_map[right_char] += 1",
          "frequency_map[right_char]",
          "frequency_map[left_char] -= 1",
          "window_end - window_start + 1",
          "del frequency_map[left_char]",
          "max_length + 1",
          "max_repeat_letter_count - 1"
      ],
      "solutions": {
          "1": "frequency_map[right_char] = 0",
          "2": "frequency_map[right_char] += 1",
          "3": "frequency_map[right_char]",
          "4": "frequency_map[left_char] -= 1",
          "5": "window_end - window_start + 1"
      },
      "hints": {
          "1": "Initialize the frequency count for a new character in the window.",
          "2": "Increase the frequency count for the current character.",
          "3": "Track the most frequent letter count in the window.",
          "4": "Decrease the frequency count when shrinking the window.",
          "5": "Track the longest valid substring length."
      },
  tags: ['sliding-window', 'string']

    },
    {
      "id": "merge-intervals",
      "title": "Merge Intervals",
      "description": "Complete the code to merge all overlapping intervals and return a list of mutually exclusive intervals.",
      "codeLines": [
          "class Interval:",
          "    def __init__(self, start, end):",
          "        self.start = start",
          "        self.end = end",
          "",
          "def merge(self, intervals):",
          "    if len(intervals) < 2:",
          "        return intervals",
          "",
          "    intervals.sort(key=lambda x: _____1_____)",
          "",
          "    mergedIntervals = []",
          "    start = intervals[0].start",
          "    end = intervals[0].end",
          "",
          "    for i in range(1, len(intervals)):",
          "        interval = intervals[i]",
          "        if interval.start _____2_____ :",
          "            end = _____3_____",
          "        else:",
          "            mergedIntervals.append(_____4_____)",
          "            start = interval.start",
          "            end = interval.end",
          "",
          "    mergedIntervals.append(_____5_____)",
          "    return mergedIntervals"
      ],
      "tokens": [
          "x.start",
          "x.end",
          "<= end",
          "> end",
          "max(interval.end, end)",
          "Interval(start, end)",
          "Interval(interval.start, interval.end)",
          "sorted(intervals)",
          "intervals[0].end"
      ],
      "solutions": {
          "1": "x.start",
          "2": "<= end",
          "3": "max(interval.end, end)",
          "4": "Interval(start, end)",
          "5": "Interval(start, end)"
      },
      "hints": {
          "1": "Sort the intervals based on their start times.",
          "2": "Check if the current interval overlaps with the previous one.",
          "3": "If overlapping, update the end time to the maximum end time.",
          "4": "Add the merged interval to the result list when a non-overlapping interval is found.",
          "5": "Ensure the last interval is also added to the result."
      },
    tags: ['merge-intervals']

    },
    {
      "id": "insert-interval",
      "title": "Insert Interval",
      "description": "Complete the code to insert a new interval into a sorted list of non-overlapping intervals and merge any necessary overlapping intervals.",
      "codeLines": [
          "def insert(self, intervals, new_interval):",
          "    merged = []",
          "    i = 0",
          "",
          "    while i < len(intervals) and intervals[i].end _____1_____ :",
          "        merged.append(intervals[i])",
          "        i += 1",
          "",
          "    while i < len(intervals) and intervals[i].start _____2_____ :",
          "        new_interval.start = _____3_____",
          "        new_interval.end = _____4_____",
          "        i += 1",
          "",
          "    merged.append(_____5_____)",
          "",
          "    while i < len(intervals):",
          "        merged.append(intervals[i])",
          "        i += 1",
          "",
          "    return merged"
      ],
      "tokens": [
          "< new_interval.start",
          "> new_interval.start",
          "<= new_interval.end",
          ">= new_interval.end",
          "min(intervals[i].start, new_interval.start)",
          "max(intervals[i].end, new_interval.end)",
          "new_interval",
          "intervals[i]",
          "merged"
      ],
      "solutions": {
          "1": "< new_interval.start",
          "2": "<= new_interval.end",
          "3": "min(intervals[i].start, new_interval.start)",
          "4": "max(intervals[i].end, new_interval.end)",
          "5": "new_interval"
      },
      "hints": {
          "1": "Skip and add to the output all intervals that end before the new interval starts.",
          "2": "Merge overlapping intervals that start before or when the new interval ends.",
          "3": "Adjust the start of the new interval to merge overlaps.",
          "4": "Adjust the end of the new interval to merge overlaps.",
          "5": "After merging, insert the new interval before adding remaining intervals."
      },
    tags: ['merge-intervals']

    },
    {
        "id": "trapping-rain-water",
        "title": "Trapping Rain Water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "codeLines": [
            "def trap(self, height):",
            "    if not height:",
            "        return 0",
            "    ",
            "    left, right = 0, len(height) - 1",
            "    left_max = right_max = water = 0",
            "",
            "    while left < right:",
            "        if height[left] _____1_____ height[right]:",
            "            if height[left] _____2_____ left_max:",
            "                left_max = height[left]",
            "            else:",
            "                water += _____3_____",
            "            left += 1",
            "        else:",
            "            if height[right] _____4_____ right_max:",
            "                right_max = height[right]",
            "            else:",
            "                water += _____5_____",
            "            right -= 1",
            "",
            "    return water"
        ],
        "tokens": [
            "<=",
            ">=",
            ">",
            "<",
            "left_max - height[left]",
            "right_max - height[right]",
            "height[left] - left_max",
            "height[right] - right_max"
        ],
        "solutions": {
            "1": "<=",
            "2": ">=",
            "3": "left_max - height[left]",
            "4": ">=",
            "5": "right_max - height[right]"
        },
        "hints": {
            "1": "Compare heights at left and right pointers to decide which side to process",
            "2": "Check if current left height creates a new maximum wall",
            "3": "Calculate water trapped at current left position using the difference between left_max and current height",
            "4": "Check if current right height creates a new maximum wall",
            "5": "Calculate water trapped at current right position using the difference between right_max and current height"
        },
        "tags": ["two-pointers", "array", "lc-hard", "meta"]
    },
    {
        "id": "regular-expression-matching",
        "title": "Regular Expression Matching",
        "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n• '.' Matches any single character\n• '*' Matches zero or more of the preceding element\nThe matching should cover the entire input string (not partial).",
        "codeLines": [
            "def isMatch(self, s: str, p: str) -> bool:",
            "    # Create DP table with one extra row and column for empty string",
            "    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]",
            "    ",
            "    # Empty pattern matches empty string",
            "    dp[0][0] = _____1_____",
            "",
            "    # Handle patterns with *",
            "    for j in range(2, len(p) + 1):",
            "        if p[j-1] == '*':",
            "            dp[0][j] = _____2_____",
            "",
            "    # Fill the DP table",
            "    for i in range(1, len(s) + 1):",
            "        for j in range(1, len(p) + 1):",
            "            if p[j-1] == '.' or p[j-1] == _____3_____:",
            "                dp[i][j] = dp[i-1][j-1]",
            "            elif p[j-1] == '*':",
            "                dp[i][j] = dp[i][j-2]  # Zero occurrence",
            "                if p[j-2] == '.' or p[j-2] == _____4_____:",
            "                    dp[i][j] = dp[i][j] or _____5_____",
            "",
            "    return dp[len(s)][len(p)]"
        ],
        "tokens": [
            "True",
            "False",
            "dp[0][j-2]",
            "s[i-1]",
            "dp[i-1][j]",
            "s[i]",
            "p[i]",
            "dp[i][j-1]"
        ],
        "solutions": {
            "1": "True",
            "2": "dp[0][j-2]",
            "3": "s[i-1]",
            "4": "s[i-1]",
            "5": "dp[i-1][j]"
        },
        "hints": {
            "1": "An empty pattern matches an empty string",
            "2": "For patterns ending with *, check if ignoring the last two characters (the * and its preceding character) still matches",
            "3": "When current pattern character matches current string character directly",
            "4": "When using *, check if the character before * matches current string character",
            "5": "With *, we can match multiple characters, so check if removing one character from string still matches"
        },
        "tags": ["dynamic-programming", "string", "recursion", "meta"]
    },
    {
        "id": "palindromic-substrings",
        "title": "Palindromic Substrings",
        "description": "Given a string, determine the number of palindromic substrings present in it. A palindromic substring is a sequence of characters that reads the same forwards and backward. The substring can be of any length, including 1.",
        "tags": ["lc-medium", "meta"],
        "codeLines": [
            "def countSubstrings(self, s: str) -> int:",
            "    # Helper function to expand from the center",
            "    def expandFromCenter(s, left, right):",
            "        count = 0",
            "        while left >= 0 and right < len(s) and s[left] == s[right]:",
            "            _____1_____",
            "            _____2_____",
            "            _____3_____",
            "        return count",
            "",
            "    count = 0",
            "    for i in range(len(s)):",
            "        count += expandFromCenter(s, i, i)",
            "        count += expandFromCenter(s, i, _____4_____)",
            "",
            "    return _____5_____"
        ],
        "tokens": [
            "count += 1",
            "left -= 1",
            "right += 1",
            "i + 1",
            "count"
        ],
        "solutions": {
            "1": "count += 1",
            "2": "left -= 1",
            "3": "right += 1",
            "4": "i + 1",
            "5": "count"
        },
        "hints": {
            "1": "Increment the count when a palindrome is found.",
            "2": "Move the left pointer one step back.",
            "3": "Move the right pointer one step forward.",
            "4": "Expand the center to check for even-length palindromes.",
            "5": "Return the total count of palindromic substrings."
        }
    },
    {
        "id": "remove-nth-node",
        "title": "Remove Nth Node From End of List",
        "description": "Given a linked list, remove the last nth node from the end of the list and return the head of the modified list.",
        "tags": ["lc-medium", "meta","two-pointers", "linkedlist"],
        "codeLines": [
            "class Node:",
            "    def __init__(self, val=0, next=None):",
            "        self.val = val",
            "        self.next = next",
            "",
            "class Solution:",
            "    def removeNth(head, n):",
            "        dummy = Node(0)",
            "        dummy.next = head",
            "        first = _____1_____",
            "        second = _____2_____",
            "",
            "        for _ in range(n + 1):",
            "            first = _____3_____",
            "",
            "        while first:",
            "            first = first.next",
            "            second = _____4_____",
            "",
            "        second.next = _____5_____",
            "        return dummy.next"
        ],
        "tokens": [
            "dummy",
            "dummy",
            "first.next",
            "second.next",
            "second.next.next"
        ],
        "solutions": {
            "1": "dummy",
            "2": "dummy",
            "3": "first.next",
            "4": "second.next",
            "5": "second.next.next"
        },
        "hints": {
            "1": "Initialize both pointers at the dummy node.",
            "2": "The second pointer also starts at dummy to maintain a gap.",
            "3": "Advance the first pointer n+1 times to create a gap.",
            "4": "Move both pointers until the first pointer reaches the end.",
            "5": "Remove the nth node by skipping it in the linked list."
        }
    },
    {
        "id": "find-min-rotated-array",
        "title": "Find Minimum in Rotated Sorted Array",
        "description": "Given a rotated sorted array that was initially sorted in ascending order, find the minimum element in O(log n) time. The array contains unique elements.",
        "tags": ["binary-search", "meta", "lc-medium", "array"],
        "codeLines": [
            "def findMin(self, nums) -> int:",
            "    left, right = 0, len(nums) - 1",
            "",
            "    while _____1_____:", 
            "        mid = (left + right) // 2",
            "",
            "        if nums[mid] _____2_____ nums[right]:",
            "            left = _____3_____",
            "        else:",
            "            right = _____4_____",
            "",
            "    return _____5_____"
        ],
        "tokens": [
            "left < right",
            "left <= right",
            ">",
            ">=",
            "mid + 1",
            "mid - 1",
            "mid",
            "nums[left]",
            "nums[right]"
        ],
        "solutions": {
            "1": "left < right",
            "2": ">",
            "3": "mid + 1",
            "4": "mid",
            "5": "nums[left]"
        },
        "hints": {
            "1": "Continue searching while left pointer is less than right pointer.",
            "2": "Check if the middle element is greater than the rightmost element.",
            "3": "If the middle element is greater, move the left pointer to mid + 1.",
            "4": "Otherwise, move the right pointer to mid, reducing the search space.",
            "5": "At the end, the left pointer will point to the minimum element."
        }
    },
    {
        "id": "pacific-atlantic-water-flow",
        "title": "Pacific Atlantic Water Flow",
        "description": "Given an m x n matrix representing the heights of an island, determine which cells allow rainwater to flow to both the Pacific and Atlantic oceans. Water flows from a cell to any adjacent cell (north, south, east, west) with a height less than or equal to the current cell.",
        "tags": ["graph", "dfs", "array", "meta", "lc-medium"],
        "codeLines": [
          "def pacificAtlantic(self, matrix):",
          "    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
          "    if not matrix or not matrix[0]:",
          "        return _____1_____",
          "",
          "    m, n = len(matrix), len(matrix[0])",
          "    pacific = [[False for _ in range(n)] for _ in range(m)]",
          "    atlantic = [[False for _ in range(n)] for _ in range(m)]",
          "",
          "    for i in range(m):",
          "        self.DFS(matrix, i, 0, pacific, _____7_____)",
          "        self.DFS(matrix, i, _____2_____, atlantic, float('-inf'))",
          "    for j in range(n):",
          "        self.DFS(matrix, 0, j, pacific, float('-inf'))",
          "        self.DFS(matrix, _____3_____, j, atlantic, float('-inf'))",
          "",
          "    res = []",
          "    for i in range(m):",
          "        for j in range(n):",
          "            if pacific[i][j] and atlantic[i][j]:",
          "                res.append([i, j])",
          "    return res",
          "",
          "def DFS(self, matrix, r, c, visited, height):",
          "    m, n = len(matrix), len(matrix[0])",
          "    if r < 0 or r >= m or c < 0 or c >= n or _____4_____ or matrix[r][c] < height:",
          "        return",
          "",
          "    visited[r][c] = _____5_____",
          "",
          "    for dir in self.DIRECTIONS:",
          "        self.DFS(matrix, r + dir[0], c + dir[1], visited, _____6_____)"
        ],
        "tokens": [
          "[]",
          "n - 1",
          "m - 1",
          "visited[r][c]",
          "True",
          "matrix[r][c]",
          "float('-inf')",
          "0",
          "False",
          "None",
          "r",
          "c"
        ],
        "solutions": {
          "1": "[]",
          "2": "n - 1",
          "3": "m - 1",
          "4": "visited[r][c]",
          "5": "True",
          "6": "matrix[r][c]",
          "7": "float('-inf')"
        },
        "hints": {
          "1": "Return an empty list if the matrix is empty.",
          "2": "For the Atlantic ocean on the left/right side, use the last column index: n - 1.",
          "3": "For the Atlantic ocean on the bottom, use the last row index: m - 1.",
          "4": "Check if the current cell was already visited to avoid cycles.",
          "5": "Mark the cell as visited by setting it to True.",
          "6": "Pass the current cell's height to ensure water flows only to cells of equal or lower height.",
          "7": "For the Pacific ocean, use a very low initial height (float('-inf')) to allow water flow."
        }
      },
      {
        "id": "validate-binary-search-tree",
        "title": "Validate Binary Search Tree",
        "description": "Determine if a given binary tree is a binary search tree (BST). In a BST, for each node: all nodes to its left have values less than the node's value, and all nodes to its right have values greater than the node's value.",
        "tags": ["tree", "dfs", "meta", "lc-medium"],
        "codeLines": [
          "class TreeNode:",
          "    def __init__(self, val=0, left=None, right=None):",
          "        self.val = val",
          "        self.left = left",
          "        self.right = right",
          "",
          "def isValidBST(self, root: TreeNode) -> bool:",
          "    def helper(node, low=_____6_____, high=_____7_____):",
          "        if not node:",
          "            return _____1_____",
          "        if not low < node.val < high:",
          "            return _____2_____",
          "        return helper(node.left, _____3_____, node.val) and helper(node.right, node.val, _____4_____)",
          "    return _____5_____"
        ],
        "tokens": [
          "True",
          "False",
          "low",
          "high",
          "helper(root)",
          "float('-inf')",
          "float('inf')",
          "None",
          "0",
          "node",
          "root",
          "isValidBST"
        ],
        "solutions": {
          "1": "True",
          "2": "False",
          "3": "low",
          "4": "high",
          "5": "helper(root)",
          "6": "float('-inf')",
          "7": "float('inf')"
        },
        "hints": {
          "1": "Return True when reaching a null node (base case).",
          "2": "Return False if the current node's value is not between low and high.",
          "3": "For the left subtree, the lower bound remains unchanged.",
          "4": "For the right subtree, the upper bound remains unchanged.",
          "5": "Start the recursion from the root node.",
          "6": "Use float('-inf') as the initial lower bound.",
          "7": "Use float('inf') as the initial upper bound."
        },
        // Explain what a binary search tree is and how it is represented in memory.
        // Then explain how we can validate each node by using upper bound and lower bound
        // Also explain how to construct a sumple BST with example
        // Exaplin like you are doing it to a noob
        "topicExplanation" : "A binary search tree (BST) is a type of binary tree where each node has at most two children, referred to as the left child and the right child. In a BST, the value of all nodes in the left subtree of a node is less than the node's value, and the value of all nodes in the right subtree is greater than the node's value. This property allows for efficient searching, insertion, and deletion operations. A BST can be represented in memory using a simple node structure with a value, a left child pointer, and a right child pointer. To validate if a binary tree is a BST, we can perform a depth-first search (DFS) traversal of the tree while keeping track of the lower and upper bounds for each node. At each node, we check if the node's value is within the bounds set by its ancestors. If the value is outside the bounds, we return False. Otherwise, we recursively validate the left and right subtrees with updated bounds. We start the validation process from the root node with initial bounds of negative infinity and positive infinity. Here's an example of constructing a simple BST: Given the values [2, 1, 3], we can create a BST with the following structure: 2 / \\ 1 3"
      },
      {
        "id": "construct-binary-tree-preorder-inorder",
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "description": "Given the preorder and inorder traversal sequences of a binary tree, reconstruct the binary tree. Assume that the tree does not contain duplicate values.",
        "tags": ["tree", "dfs", "meta", "lc-medium"],
        "codeLines": [
          "class Solution:",
          "    def __init__(self):",
          "        self.preIndex = 0",
          "        self.inorderIndexMap = {}",
          "",
          "    def buildTree(self, preorder, inorder):",
          "        # Create a dictionary to store the indices of values in the inorder list",
          "        self.inorderIndexMap = _____4_____",
          "        # Call the helper function to construct the binary tree",
          "        return _____5_____",
          "",
          "    def _constructTree(self, preorder, inStart, inEnd):",
          "        # Base case: If the start index is greater than the end index, return None",
          "        if inStart > inEnd:",
          "            return _____1_____",
          "",
          "        # Get the value at the current preorder index as the root value",
          "        rootVal = preorder[self.preIndex]",
          "        self.preIndex _____6_____",
          "        root = TreeNode(rootVal)",
          "",
          "        # If the start index is equal to the end index, return the root node",
          "        if inStart == inEnd:",
          "            return _____2_____",
          "",
          "        # Find the index of the root value in the inorder list",
          "        inIndex = _____7_____",
          "",
          "        # Recursively construct the left and right subtrees",
          "        root.left = self._constructTree(preorder, inStart, inIndex - 1)",
          "        root.right = self._constructTree(preorder, inIndex + 1, inEnd)",
          "        return _____3_____"
        ],
        "tokens": [
          "None",
          "root",
          "root",
          "{val: idx for idx, val in enumerate(inorder)}",
          "self._constructTree(preorder, 0, len(inorder) - 1)",
          "+= 1",
          "self.inorderIndexMap[rootVal]",
          "preorder",
          "inorder",
          "TreeNode(rootVal)",
          "self.preIndex",
          "0"
        ],
        "solutions": {
          "1": "None",
          "2": "root",
          "3": "root",
          "4": "{val: idx for idx, val in enumerate(inorder)}",
          "5": "self._constructTree(preorder, 0, len(inorder) - 1)",
          "6": "+= 1",
          "7": "self.inorderIndexMap[rootVal]"
        },
        "hints": {
          "1": "Return None when the current subtree has no nodes (inStart > inEnd).",
          "2": "If there's only one element, return the root node.",
          "3": "After constructing left and right subtrees, return the root node.",
          "4": "Build a map from each value in inorder to its index for quick lookups.",
          "5": "Initiate the recursive construction using the entire inorder range.",
          "6": "Increment preIndex to move to the next root candidate in preorder.",
          "7": "Retrieve the index of the current root from the inorder index map."
        },
      },
      {
        "id": "print-level-order-binary-tree",
        "title": "Print Level Order for a Binary Tree",
        "description": "Given a binary tree, print its level order traversal. For each level, print the node values (or 'null' if a node is missing) in order. Stop processing further levels if the current level contains only nodes without children.",
        "tags": ["tree", "bfs", "fundamentals", "meta", "lc-medium"],
        "codeLines": [
          "def printTree(root):",
          "    if not root:",
          "        return",
          "",
          "    queue = [root]",
          "    while queue:",
          "        levelSize = _____1_____",
          "        isLastLevel = True",
          "",
          "        for _ in _____2_____:",
          "            curr = _____3_____",
          "            if curr:",
          "                print(_____4_____, end=' ')",
          "                queue.append(_____5_____)",
          "                queue.append(curr.right)",
          "                if _____6_____:",
          "                    isLastLevel = False",
          "            else:",
          "                print('null', end=' ')",
          "",
          "        if isLastLevel:",
          "            _____7_____"
        ],
        "tokens": [
          "len(queue)",
          "range(levelSize)",
          "queue.pop(0)",
          "curr.val",
          "curr.left",
          "curr.left or curr.right",
          "break",
          "None",
          "queue[0]",
          "print('null')",
          "True",
          "exit()"
        ],
        "solutions": {
          "1": "len(queue)",
          "2": "range(levelSize)",
          "3": "queue.pop(0)",
          "4": "curr.val",
          "5": "curr.left",
          "6": "curr.left or curr.right",
          "7": "break"
        },
        "hints": {
          "1": "Compute the number of nodes at the current level.",
          "2": "Iterate over all nodes in the current level.",
          "3": "Remove the first node from the queue for processing.",
          "4": "Print the value of the current node.",
          "5": "Append the left child of the current node to the queue.",
          "6": "Check if the current node has any children (left or right).",
          "7": "Terminate the loop if the current level has no children."
        }
      },
      {
        "id": "simplify-path",
        "title": "Simplify Path",
        "description": "Given an absolute file path in a Unix-style file system, simplify it by resolving '..' to go to the previous directory, ignoring '.' and extra slashes. Return the shortest canonical path.",
        "tags": ["stack", "string", "fundamentals", "meta", "lc-easy"],
        "codeLines": [
          "def simplifyPath(self, path):",
          "    # Create a stack to store the simplified path components",
          "    stack = []",
          "    # Get components by splitting the input path",
          "    components = _____4_____",
          "    for p in components:",
          "        if p == '..':",
          "            # If the component is '..', pop the last component from the stack",
          "            if stack:",
          "                _____1_____",
          "        elif p and p != '.':",
          "            # If the component is a valid directory name, push it onto the stack",
          "            _____2_____",
          "        else:",
          "            _____3_____",
          "    # Optional: finalize processing",
          "    _____5_____",
          "    return _____6_____ + _____7_____"
        ],
        "tokens": [
          "stack.pop()",
          "stack.append(p)",
          "continue",
          "path.split('/')",
          "pass",
          "'/'",
          "\"/\".join(stack)",
          "pop()",
          "append(p)",
          "None",
          "split('/')",
          "''"
        ],
        "solutions": {
          "1": "stack.pop()",
          "2": "stack.append(p)",
          "3": "continue",
          "4": "path.split('/')",
          "5": "pass",
          "6": "'/'",
          "7": "\"/\".join(stack)"
        },
        "hints": {
          "1": "When encountering '..', remove the last directory from the stack if possible.",
          "2": "Append valid directory names to the stack.",
          "3": "Skip over empty strings or '.' which denote the current directory.",
          "4": "Split the path by '/' to obtain its components.",
          "5": "This placeholder does nothing; it's optional.",
          "6": "The simplified path should start with a '/'.",
          "7": "Join the stack contents with '/' to form the final simplified path."
        }
      },
      {
        "id": "decimal-to-binary-conversion",
        "title": "Decimal to Binary Conversion",
        "description": "Given a positive integer n, write a function that returns its binary equivalent as a string without using any in-built binary conversion functions.",
        "tags": [ "stack", "string", "fundamentals", "lc-medium", "meta"],
        "codeLines": [
          "def decimalToBinary(self, num):",
          "    # Create an empty stack to hold binary digits.",
          "    stack = _____1_____",
          "    # Continue the loop until num becomes 0.",
          "    while _____2_____:",
          "        # Push the remainder of num divided by 2 onto the stack.",
          "        stack.append(_____3_____)",
          "        # Update num by integer division (floor division) by 2.",
          "        _____4_____",
          "    outputFormat = _____5_____",
          "    binaryString = _____6_____",
          "    return _____7_____"
        ],
        "tokens": [
          "[]",
          "num > 0",
          "num % 2",
          "num //= 2",
          "num /= 2",
          "stack",
          "''.join(str(i) for i in outputFormat)",
          "binaryString",
          "binaryString[::-1]",
          "reversed(stack)",
          "num",
          "join",
          "int",
          "True"
        ],
        "solutions": {
          "1": "[]",
          "2": "num > 0",
          "3": "num % 2",
          "4": "num //= 2",
          "5": "reversed(stack)",
          "6": "''.join(str(i) for i in reversedStack)",
          "7": "binaryString"
        },
        "hints": {
          "1": "Initialize the stack as an empty list.",
          "2": "Loop until num becomes 0.",
          "3": "Append the remainder when num is divided by 2 to the stack.",
          "4": "Update num using floor division by 2.",
          "5": "Reverse the stack to correct the digit order.",
          "6": "Join the reversed stack elements into a string.",
          "7": "Return the constructed binary string."
        }
      }
      
      
      
      
    
    
  ];